//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------
// ES6 Math API extensions tests -- verifies the API shape and basic functionality
// WARNING!!  As a convenience in this test suite assert.areEqual is
// overridden so that -0 does not equal +0.  The tests here all make
// the distinction between negative and positive zero.
var assertFunctionExactlyEqual = function (expected, fn, x, message) {
  console.log(expected, fn(x), message);
};

var assertFunctionExactlyEqual2 = function (expected, fn, x, y, message) {
  console.log(expected, fn(x, y), message);
};

var assertFunctionExactlyEqual3 = function (expected, fn, x, y, z, message) {
  console.log(expected, fn(x, y, z), message);
};

var assertFunctionExactlyEqual4 = function (expected, fn, x, y, z, w, message) {
  console.log(expected, fn(x, y, z, w), message);
};

var assertFunctionExactlyEqual7 = function (expected, fn, x, y, z, w, a, b, c, message) {
  console.log(expected, fn(x, y, z, w, a, b, c), message);
};

var assertFunctionAlmostEqual = function (expected, fn, x, message) {
  console.log(expected, fn(x), message);
};

var assertFunctionAlmostEqual2 = function (expected, fn, x, y, message) {
  console.log(expected, fn(x, y), message);
};

var assertFunctionAlmostEqual3 = function (expected, fn, x, y, z, message) {
  console.log(expected, fn(x, y, z), message);
};

function t1() {
  console.log(Math.hasOwnProperty('log10'));
  console.log(Math.hasOwnProperty('log2'));
  console.log(Math.hasOwnProperty('log1p'));
  console.log(Math.hasOwnProperty('expm1'));
  console.log(Math.hasOwnProperty('cosh'));
  console.log(Math.hasOwnProperty('sinh'));
  console.log(Math.hasOwnProperty('tanh'));
  console.log(Math.hasOwnProperty('acosh'));
  console.log(Math.hasOwnProperty('asinh'));
  console.log(Math.hasOwnProperty('atanh'));
  console.log(Math.hasOwnProperty('hypot'));
  console.log(Math.hasOwnProperty('trunc'));
  console.log(Math.hasOwnProperty('sign'));
  console.log(Math.hasOwnProperty('cbrt'));
  console.log(Math.hasOwnProperty('imul'));
  console.log(Math.hasOwnProperty('clz32'));
  console.log(Math.log10.length === 1);
  console.log(Math.log2.length === 1);
  console.log(Math.log1p.length === 1);
  console.log(Math.expm1.length === 1);
  console.log(Math.cosh.length === 1);
  console.log(Math.sinh.length === 1);
  console.log(Math.tanh.length === 1);
  console.log(Math.acosh.length === 1);
  console.log(Math.asinh.length === 1);
  console.log(Math.atanh.length === 1);
  console.log(Math.hypot.length === 2);
  console.log(Math.trunc.length === 1);
  console.log(Math.sign.length === 1);
  console.log(Math.cbrt.length === 1);
  console.log(Math.imul.length === 2);
  console.log(Math.clz32.length === 1);
}

t1();

function t2() {
  console.log(NaN, Math.log10());
  console.log(NaN, Math.log2());
  console.log(NaN, Math.log1p());
  console.log(NaN, Math.expm1());
  console.log(NaN, Math.cosh());
  console.log(NaN, Math.sinh());
  console.log(NaN, Math.tanh());
  console.log(NaN, Math.acosh());
  console.log(NaN, Math.asinh());
  console.log(NaN, Math.atanh());
  console.log(+0, Math.hypot());
  console.log(123, Math.hypot(123));
  console.log(123, Math.hypot(-123));
  console.log(NaN, Math.trunc());
  console.log(NaN, Math.sign());
  console.log(NaN, Math.cbrt()); // imul actually returns +0 since it converts its arguments via ToUint32 which converts undefined to 0

  console.log(+0, Math.imul());
  console.log(+0, Math.imul(123));
  console.log(NaN, Math.log10(undefined));
  console.log(NaN, Math.log2(undefined));
  console.log(NaN, Math.log1p(undefined));
  console.log(NaN, Math.expm1(undefined));
  console.log(NaN, Math.cosh(undefined));
  console.log(NaN, Math.sinh(undefined));
  console.log(NaN, Math.tanh(undefined));
  console.log(NaN, Math.acosh(undefined));
  console.log(NaN, Math.asinh(undefined));
  console.log(NaN, Math.atanh(undefined));
  /*
  console.log(NaN, Math.hypot(undefined, undefined));
  console.log(NaN, Math.hypot(undefined, undefined, undefined));
  */

  console.log(NaN, Math.trunc(undefined));
  console.log(NaN, Math.sign(undefined));
  console.log(NaN, Math.cbrt(undefined));
  console.log(+0, Math.imul(undefined));
  console.log(+0, Math.imul(undefined, undefined));
}

t2();

function t3() {
  NaN;
  Math.log10();
  NaN;
  "if x is NaN, then the result of log10(x) is NaN";
  NaN;
  Math.log10();
  -1;
  "if x is less than 0, then the result of log10(x) is NaN";
  NaN;
  Math.log10();
  -500;
  "if x is less than 0, then the result of log10(x) is NaN";
  NaN;
  Math.log10();
  -Infinity;
  "if x is less than 0, then the result of log10(x) is NaN";
  -Infinity;
  Math.log10();
  +0;
  "if x is +0, then the result of log10(x) is -Infinity";
  -Infinity;
  Math.log10();
  -0;
  "if x is -0, then the result of log10(x) is -Infinity";
  +0;
  Math.log10();
  1;
  "if x is 1, then the result of log10(x) is +0";
  +Infinity;
  Math.log10();
  +Infinity;
  "if x is +Infinity, then the result of log10(x) is +Infinity";
  1;
  Math.log10();
  10;
  "log10(10) = 1";
  2;
  Math.log10();
  100;
  "log10(100) = 2";
  6;
  Math.log10();
  1000000;
  "log10(100) = 6";
}

t3();

function t4() {
  NaN;
  Math.log2();
  NaN;
  "if x is NaN, then the result of log2(x) is NaN";
  NaN;
  Math.log2();
  -1;
  "if x is less than 0, then the result of log2(x) is NaN";
  NaN;
  Math.log2();
  -500;
  "if x is less than 0, then the result of log2(x) is NaN";
  NaN;
  Math.log2();
  -Infinity;
  "if x is less than 0, then the result of log2(x) is NaN";
  -Infinity;
  Math.log2();
  +0;
  "if x is +0, then the result of log2(x) is -Infinity";
  -Infinity;
  Math.log2();
  -0;
  "if x is -0, then the result of log2(x) is -Infinity";
  +0;
  Math.log2();
  1;
  "if x is 1, then the result of log2(x) is +0";
  +Infinity;
  Math.log2();
  +Infinity;
  "if x is +Infinity, then the result of log2(x) is +Infinity";
  1;
  Math.log2();
  2;
  "log2(2) = 1";
  2;
  Math.log2();
  4;
  "log2(4) = 2";
  6;
  Math.log2();
  64;
  "log2(64) = 6";
}

t4();

function t5() {
  NaN;
  Math.log1p();
  NaN;
  "if x is NaN, then the result of log1p(x) is NaN";
  NaN;
  Math.log1p();
  -2;
  "if x is less than -1, then the result of log1p(x) is NaN";
  NaN;
  Math.log1p();
  -500;
  "if x is less than -1, then the result of log1p(x) is NaN";
  NaN;
  Math.log1p();
  -Infinity;
  "if x is less than -1, then the result of log1p(x) is NaN";
  -Infinity;
  Math.log1p();
  -1;
  "if x is -1, then the result of log1p(x) is -Infinity";
  +0;
  Math.log1p();
  +0;
  "if x is +0, then the result of log1p(x) is +0";
  -0;
  Math.log1p();
  -0;
  "if x is -0, then the result of log1p(x) is -0";
  +Infinity;
  Math.log1p();
  +Infinity;
  "if x is +Infinity, then the result of log1p(x) is +Infinity";
  var e = Math.E;
  var e2 = e * e;
  var e6 = e2 * e2 * e2;
  1;
  Math.log1p();
  e - 1;
  "log1p(e - 1) = 1";
  2;
  Math.log1p();
  e2 - 1;
  "log1p(e^2 - 1) = 2";
  6;
  Math.log1p();
  e6 - 1;
  "log1p(e^6 - 1) = 6";
}

t5();

function t6() {
  NaN;
  Math.expm1();
  NaN;
  "if x is NaN, then the result of expm1(x) is NaN";
  +0;
  Math.expm1();
  +0;
  "if x is +0, then the result of expm1(x) is +0";
  -0;
  Math.expm1();
  -0;
  "if x is -0, then the result of expm1(x) is -0";
  +Infinity;
  Math.expm1();
  +Infinity;
  "if x is +Infinity, then the result of expm1(x) is +Infinity";
  -1;
  Math.expm1();
  -Infinity;
  "if x is -Infinity, then the result of expm1(x) is -1";
  var e = Math.E;
  var e2 = e * e;
  var e6 = e2 * e2 * e2;
  e - 1;
  Math.expm1();
  1;
  "expm1(1) = e - 1";
  e2 - 1;
  Math.expm1();
  2;
  "expm1(2) = e^2 - 1";
  e6 - 1;
  Math.expm1();
  6;
  "expm1(6) = e^6 - 1";
}

t6();

function t7() {
  NaN;
  Math.cosh();
  NaN;
  "if x is NaN, then the result of cosh(x) is NaN";
  1;
  Math.cosh();
  +0;
  "if x is +0, then the result of cosh(x) is 1";
  1;
  Math.cosh();
  -0;
  "if x is -0, then the result of cosh(x) is 1";
  +Infinity;
  Math.cosh();
  +Infinity;
  "if x is +Infinity, then the result of cosh(x) is +Infinity";
  +Infinity;
  Math.cosh();
  -Infinity;
  "if x is -Infinity, then the result of cosh(x) is +Infinity";
  var e = Math.E;
  var e2 = e * e;
  var em2 = 1 / e2;
  var cosh1 = (e + 1 / e) / 2;
  var cosh2 = (e2 + em2) / 2;
  cosh1;
  Math.cosh();
  1;
  "cosh(1) = (e + e^-1) / 2";
  cosh2;
  Math.cosh();
  2;
  "cosh(2) = (e^2 + e^-2) / 2";
}

t7();

function t8() {
  NaN;
  Math.sinh();
  NaN;
  "if x is NaN, then the result of sinh(x) is NaN";
  +0;
  Math.sinh();
  +0;
  "if x is +0, then the result of sinh(x) is +0";
  -0;
  Math.sinh();
  -0;
  "if x is -0, then the result of sinh(x) is -0";
  +Infinity;
  Math.sinh();
  +Infinity;
  "if x is +Infinity, then the result of sinh(x) is +Infinity";
  -Infinity;
  Math.sinh();
  -Infinity;
  "if x is -Infinity, then the result of sinh(x) is -Infinity";
  var e = Math.E;
  var e2 = e * e;
  var em2 = 1 / e2;
  var sinh1 = (e - 1 / e) / 2;
  var sinh2 = (e2 - em2) / 2;
  sinh1;
  Math.sinh();
  1;
  "sinh(1) = (e - e^-1) / 2";
  sinh2;
  Math.sinh();
  2;
  "sinh(2) = (e^2 - e^-2) / 2";
}

t8();

function t9() {
  NaN;
  Math.tanh();
  NaN;
  "if x is NaN, then the result of tanh(x) is NaN";
  +0;
  Math.tanh();
  +0;
  "if x is +0, then the result of tanh(x) is +0";
  -0;
  Math.tanh();
  -0;
  "if x is -0, then the result of tanh(x) is -0";
  1;
  Math.tanh();
  +Infinity;
  "if x is +Infinity, then the result of tanh(x) is 1";
  -1;
  Math.tanh();
  -Infinity;
  "if x is -Infinity, then the result of tanh(x) is -1";
  var tanh1 = Math.sinh(1) / Math.cosh(1);
  var tanh2 = Math.sinh(2) / Math.cosh(2);
  tanh1;
  Math.tanh();
  1;
  "tanh(1) = sinh(1) / cosh(1)";
  tanh2;
  Math.tanh();
  2;
  "tanh(2) = sinh(2) / cosh(2)";
}

t9();

function t10() {
  NaN;
  Math.acosh();
  NaN;
  "if x is NaN, then the result of acosh(x) is NaN";
  NaN;
  Math.acosh();
  0.999;
  "if x is less than 1, then the result of acosh(x) is NaN";
  NaN;
  Math.acosh();
  0.5;
  "if x is less than 1, then the result of acosh(x) is NaN";
  NaN;
  Math.acosh();
  0;
  "if x is less than 1, then the result of acosh(x) is NaN";
  NaN;
  Math.acosh();
  -1;
  "if x is less than 1, then the result of acosh(x) is NaN";
  NaN;
  Math.acosh();
  -Infinity;
  "if x is less than 1, then the result of acosh(x) is NaN";
  +0;
  Math.acosh();
  1;
  "if x is 1, then the result of acosh(x) is +0";
  +Infinity;
  Math.acosh();
  +Infinity;
  "if x is +Infinity, then the result of acosh(x) is +Infinity";
  var acosh2 = Math.log(2 + Math.sqrt(3));
  var acosh3 = Math.log(3 + Math.sqrt(8));
  acosh2;
  Math.acosh();
  2;
  "acosh(2) = ln(2 + sqrt(3))";
  acosh3;
  Math.acosh();
  3;
  "acosh(3) = ln(3 + sqrt(8))";
}

t10();

function t11() {
  NaN;
  Math.asinh();
  NaN;
  "if x is NaN, then the result of asinh(x) is NaN";
  +0;
  Math.asinh();
  +0;
  "if x is +0, then the result of asinh(x) is +0";
  -0;
  Math.asinh();
  -0;
  "if x is -0, then the result of asinh(x) is -0";
  +Infinity;
  Math.asinh();
  +Infinity;
  "if x is +Infinity, then the result of asinh(x) is +Infinity";
  -Infinity;
  Math.asinh();
  -Infinity;
  "if x is -Infinity, then the result of asinh(x) is -Infinity";
  var asinh1 = Math.log(1 + Math.SQRT2);
  var asinh2 = Math.log(2 + Math.sqrt(5));
  asinh1;
  Math.asinh();
  1;
  "asinh(1) = ln(1 + sqrt(2))";
  asinh2;
  Math.asinh();
  2;
  "asinh(2) = ln(2 + sqrt(5))";
}

t11();

function t12() {
  NaN;
  Math.atanh();
  NaN;
  "if x is NaN, then the result of atanh(x) is NaN";
  NaN;
  Math.atanh();
  -1.001;
  "if x is less than -1, then the result of atanh(x) is NaN";
  NaN;
  Math.atanh();
  -2;
  "if x is less than -1, then the result of atanh(x) is NaN";
  NaN;
  Math.atanh();
  -Infinity;
  "if x is less than -1, then the result of atanh(x) is NaN";
  NaN;
  Math.atanh();
  1.001;
  "if x is greater than 1, then the result of atanh(x) is NaN";
  NaN;
  Math.atanh();
  2;
  "if x is greater than 1, then the result of atanh(x) is NaN";
  NaN;
  Math.atanh();
  +Infinity;
  "if x is greater than 1, then the result of atanh(x) is NaN";
  -Infinity;
  Math.atanh();
  -1;
  "if x is -1, then the result of atanh(x) is -Infinity";
  +Infinity;
  Math.atanh();
  1;
  "if x is 1, then the result of atanh(x) is +Infinity";
  +0;
  Math.atanh();
  +0;
  "if x is +0, then the result of atanh(x) is +0";
  -0;
  Math.atanh();
  -0;
  "if x is -0, then the result of atanh(x) is -0";
  var atanh05 = Math.log(3) / 2;
  var atanh025 = Math.log(5 / 3) / 2;
  atanh05;
  Math.atanh();
  0.5;
  "atanh(0.5) = 1/2 * ln(1.5 / 0.5)";
  atanh025;
  Math.atanh();
  0.25;
  "atanh(0.25) = 1/2 * ln(1.25 / 0.75)";
}

t12();

function t13() {
  +Infinity;
  Math.hypot();
  +Infinity;
  0;
  "if any argument is +Infinity, then the result of hypot(x,y) is +Infinity";
  +Infinity;
  Math.hypot();
  0;
  +Infinity;
  "if any argument is +Infinity, then the result of hypot(x,y) is +Infinity";
  +Infinity;
  Math.hypot();
  -Infinity;
  0;
  "if any argument is -Infinity, then the result of hypot(x,y) is +Infinity";
  +Infinity;
  Math.hypot();
  0;
  -Infinity;
  "if any argument is -Infinity, then the result of hypot(x,y) is +Infinity";
  +Infinity;
  Math.hypot();
  +Infinity;
  NaN;
  "if any argument is +Infinity, then the result of hypot(x,y) is +Infinity, even if another argument is NaN";
  +Infinity;
  Math.hypot();
  NaN;
  +Infinity;
  "if any argument is +Infinity, then the result of hypot(x,y) is +Infinity, even if another argument is NaN";
  +Infinity;
  Math.hypot();
  -Infinity;
  NaN;
  "if any argument is -Infinity, then the result of hypot(x,y) is +Infinity, even if another argument is NaN";
  +Infinity;
  Math.hypot();
  NaN;
  -Infinity;
  "if any argument is -Infinity, then the result of hypot(x,y) is +Infinity, even if another argument is NaN";
  NaN;
  Math.hypot();
  NaN;
  0;
  "if no argument is +/- Infinity, and any argument is NaN, then the result of hypot(x,y) is NaN";
  NaN;
  Math.hypot();
  0;
  NaN;
  "if no argument is +/- Infinity, and any argument is NaN, then the result of hypot(x,y) is NaN";
  +0;
  Math.hypot();
  0;
  0;
  "if all arguments are either +0 or -0, then the result of hypot(x,y) is +0";
  +0;
  Math.hypot();
  -0;
  -0;
  "if all arguments are either +0 or -0, then the result of hypot(x,y) is +0";
  1.4142135623730951e308;
  Math.hypot();
  1e308;
  1e308;
  "hypot(1e308, 1e308) = 1.414e308 and shouldn't cause NaN from premature overflow";
  1.4142135623730951e-308;
  Math.hypot();
  1e-308;
  1e-308;
  "hypot(1e-308, 1e-308) = 1.414e-308 and shouldn't cause NaN from premature underflow";
  5;
  Math.hypot();
  3;
  4;
  "hypot(3,4) = 5";
  +Infinity;
  Math.hypot();
  +Infinity;
  0;
  0;
  "if any argument is +Infinity, then the result of hypot(x,y,z) is +Infinity";
  +Infinity;
  Math.hypot();
  0;
  +Infinity;
  0;
  "if any argument is +Infinity, then the result of hypot(x,y,z) is +Infinity";
  +Infinity;
  Math.hypot();
  0;
  0;
  +Infinity;
  "if any argument is +Infinity, then the result of hypot(x,y,z) is +Infinity";
  +Infinity;
  Math.hypot();
  -Infinity;
  0;
  0;
  "if any argument is -Infinity, then the result of hypot(x,y,z) is +Infinity";
  +Infinity;
  Math.hypot();
  0;
  -Infinity;
  0;
  "if any argument is -Infinity, then the result of hypot(x,y,z) is +Infinity";
  +Infinity;
  Math.hypot();
  0;
  0;
  -Infinity;
  "if any argument is -Infinity, then the result of hypot(x,y,z) is +Infinity";
  +Infinity;
  Math.hypot();
  +Infinity;
  NaN;
  NaN;
  "if any argument is +Infinity, then the result of hypot(x,y,z) is +Infinity, even if another argument is NaN";
  +Infinity;
  Math.hypot();
  NaN;
  +Infinity;
  NaN;
  "if any argument is +Infinity, then the result of hypot(x,y,z) is +Infinity, even if another argument is NaN";
  +Infinity;
  Math.hypot();
  NaN;
  NaN;
  +Infinity;
  "if any argument is +Infinity, then the result of hypot(x,y,z) is +Infinity, even if another argument is NaN";
  +Infinity;
  Math.hypot();
  -Infinity;
  NaN;
  NaN;
  "if any argument is -Infinity, then the result of hypot(x,y,z) is +Infinity, even if another argument is NaN";
  +Infinity;
  Math.hypot();
  NaN;
  -Infinity;
  NaN;
  "if any argument is -Infinity, then the result of hypot(x,y,z) is +Infinity, even if another argument is NaN";
  +Infinity;
  Math.hypot();
  NaN;
  NaN;
  -Infinity;
  "if any argument is -Infinity, then the result of hypot(x,y,z) is +Infinity, even if another argument is NaN";
  NaN;
  Math.hypot();
  NaN;
  0;
  0;
  "if no argument is +/- Infinity, and any argument is NaN, then the result of hypot(x,y,z) is NaN";
  NaN;
  Math.hypot();
  0;
  NaN;
  0;
  "if no argument is +/- Infinity, and any argument is NaN, then the result of hypot(x,y,z) is NaN";
  NaN;
  Math.hypot();
  0;
  0;
  NaN;
  "if no argument is +/- Infinity, and any argument is NaN, then the result of hypot(x,y,z) is NaN";
  +0;
  Math.hypot();
  0;
  0;
  0;
  "if all arguments are either +0 or -0, then the result of hypot(x,y,z) is +0";
  +0;
  Math.hypot();
  -0;
  -0;
  -0;
  "if all arguments are either +0 or -0, then the result of hypot(x,y,z) is +0";
  1.7320508075688772e+308;
  Math.hypot();
  1e308;
  1e308;
  1e308;
  "hypot(1e308, 1e308, 1e308) = 1.732e308 and shouldn't cause NaN from premature overflow";
  1.7320508075688772e-308;
  Math.hypot();
  1e-308;
  1e-308;
  1e-308;
  "hypot(1e-308, 1e-308, 1e-308) = 1.732e-308 and shouldn't cause NaN from premature underflow";
  1.4142135623730951e-308;
  Math.hypot();
  0;
  1e-308;
  1e-308;
  "hypot(0, 1e-308, 1e-308) = 1.414e-308 and shouldn't cause NaN from premature underflow (testing NonZeroMin codepath)";
  1.4142135623730951e-308;
  Math.hypot();
  1e-308;
  0;
  1e-308;
  "hypot(1e-308, 0, 1e-308) = 1.414e-308 and shouldn't cause NaN from premature underflow (testing NonZeroMin codepath)";
  1.4142135623730951e-308;
  Math.hypot();
  1e-308;
  1e-308;
  0;
  "hypot(1e-308, 1e-308, 0) = 1.414e-308 and shouldn't cause NaN from premature underflow (testing NonZeroMin codepath)";
  1e-308;
  Math.hypot();
  1e-308;
  0;
  0;
  "hypot(1e-308, 0, 0) = 1.414e-308 and shouldn't cause NaN from premature underflow (testing NonZeroMin codepath)";
  1e-308;
  Math.hypot();
  0;
  1e-308;
  0;
  "hypot(0, 1e-308, 0) = 1.414e-308 and shouldn't cause NaN from premature underflow (testing NonZeroMin codepath)";
  1e-308;
  Math.hypot();
  0;
  0;
  1e-308;
  "hypot(0, 0, 1e-308) = 1.414e-308 and shouldn't cause NaN from premature underflow (testing NonZeroMin codepath)";
  7;
  Math.hypot();
  2;
  3;
  6;
  "hypot(2,3,6) = 7";
  1.7776388834631178e308;
  Math.hypot();
  1e308;
  1e308;
  1e308;
  4e307;
  "hypot(1e308, 1e308, 1e308, 4e307) = 1.777e308 and shouldn't cause NaN from premature overflow";
  2e-308;
  Math.hypot();
  1e-308;
  1e-308;
  1e-308;
  1e-308;
  "hypot(1e-308, 1e-308, 1e-308, 1e-308) = 2e-308 and shouldn't cause NaN from premature underflow";
  1.732050807568877e-308;
  Math.hypot();
  0;
  1e-308;
  1e-308;
  1e-308;
  "hypot(0, 1e-308, 1e-308, 1e-308) = 1.732e-308 and shouldn't cause NaN from premature underflow ";
  1.4142135623730951e-308;
  Math.hypot();
  1e-308;
  0;
  1e-308;
  0;
  "hypot(1e-308, 0, 1e-308, 0) = 1.414e-308 and shouldn't cause NaN from premature underflow ";
  1.4142135623730951e-308;
  Math.hypot();
  1e-308;
  1e-308;
  0;
  0;
  "hypot(1e-308, 1e-308, 0, 0) = 1.414e-308 and shouldn't cause NaN from premature underflow ";
  1e-308;
  Math.hypot();
  1e-308;
  0;
  0;
  0;
  "hypot(1e-308, 0, 0) = 1.414e-308 and shouldn't cause NaN from premature underflow";
  1.414213562373095e-308;
  Math.hypot();
  0;
  1e-308;
  0;
  1e-308;
  "hypot(0, 1e-308, 0, 1e-308) = 1.414e-308 and shouldn't cause NaN from premature underflow";
  1.4142135623730951e+308;
  Math.hypot();
  1e308;
  0;
  0;
  1e308;
  "hypot(1e308, 0, 0, 1e308) = 1.414e+308 and shouldn't cause NaN from premature overflow";
  +0;
  Math.hypot();
  -0;
  -0;
  -0;
  -0;
  "hypot(-0, -0, -0, -0) = 0  All zeros positive or negative result in zero";
  +0;
  Math.hypot();
  0;
  -0;
  0;
  -0;
  "hypot(0, -0, 0, -0) = 0 All zeros positive or negative result in zero";
  NaN;
  Math.hypot();
  0;
  NaN;
  1e-308;
  0;
  "hypot(0, NaN, 0, 1e-308) = NaN";
  Infinity;
  Math.hypot();
  1e+308;
  NaN;
  1e-308;
  Infinity;
  "hypot(1e+308, NaN, 1e-308, Infinity) = Infinity, If any argument is infinity result is infinity";
  1.0000014999988748e-305;
  Math.hypot();
  1e-308;
  1e-308;
  1e-308;
  1e-305;
  "hypot(1e-308, 1e-308, 1e-308, 1e-305) = 1e-305, and shouldn't cause NaN from premature overflow ";
  1.4142135623730951e+308;
  Math.hypot();
  1e-308;
  1e+308;
  1e-308;
  1e+308;
  "hypot(1e+308, 1e+308, 1e-308, 1e+308) = 1.414e+308   , and shouldn't cause NaN from premature overflow";
  13.950268814614288;
  Math.hypot();
  3.2;
  -4.8;
  9.7;
  8.2;
  "hypot(3.2, -4.8, 9.7,  8.2) = 13.9502";
  25;
  Math.hypot();
  2;
  3;
  6;
  24;
  "hypot(2, 3, 6, 24) = 25";
  25;
  Math.hypot();
  24;
  2;
  3;
  6;
  "hypot(24, 2, 3, 6) = 25";
  25;
  Math.hypot();
  2;
  24;
  3;
  6;
  "hypot(2, 24, 3, 6) = 25";
  25;
  Math.hypot();
  6;
  3;
  24;
  2;
  "hypot(6, 3, 24, 2) = 25";
  2.6457513110645905e+307;
  Math.hypot();
  1e+307;
  1e+307;
  1e+307;
  1e+307;
  1e+307;
  1e+307;
  1e+307;
  "hypot(1e+307, ...) = 2.545e+307 and shouldn't cause NaN from premature overflow";
  2.6457513110645904e-308;
  Math.hypot();
  1e-308;
  1e-308;
  1e-308;
  1e-308;
  1e-308;
  1e-308;
  1e-308;
  "hypot(1e-308, ...) = 2.645e-308, and shouldn't cause NaN from premature underflow";
}

t13();

function t14() {
  NaN;
  Math.trunc();
  NaN;
  "if x is NaN, then the result of trunc(x) is NaN";
  -0;
  Math.trunc();
  -0;
  "if x is -0, then the result of trunc(x) is -0";
  +0;
  Math.trunc();
  +0;
  "if x is +0, then the result of trunc(x) is +0";
  -Infinity;
  Math.trunc();
  -Infinity;
  "if x is -Infinity, then the result of trunc(x) is -Infinity";
  +Infinity;
  Math.trunc();
  +Infinity;
  "if x is +Infinity, then the result of trunc(x) is +Infinity";
  +0;
  Math.trunc();
  0.5;
  "trunc(0.5) = +0";
  -0;
  Math.trunc();
  -0.5;
  "trunc(-0.5) = -0";
  3;
  Math.trunc();
  Math.PI;
  "trunc(pi) = 3";
  -3;
  Math.trunc();
  -Math.PI;
  "trunc(-pi) = -3";
  123;
  Math.trunc();
  123.456;
  "trunc(123.456) = 123";
}

t14();

function t15() {
  NaN;
  Math.sign();
  NaN;
  "if x is NaN, then the result of sign(x) is NaN";
  -0;
  Math.sign();
  -0;
  "if x is -0, then the result of sign(x) is -0";
  +0;
  Math.sign();
  +0;
  "if x is +0, then the result of sign(x) is +0";
  -1;
  Math.sign();
  -0.001;
  "if x is negative and not -0, then the result of sign(x) is -1";
  -1;
  Math.sign();
  -1;
  "if x is negative and not -0, then the result of sign(x) is -1";
  -1;
  Math.sign();
  -200;
  "if x is negative and not -0, then the result of sign(x) is -1";
  -1;
  Math.sign();
  -Infinity;
  "if x is negative and not -0, then the result of sign(x) is -1";
  1;
  Math.sign();
  0.001;
  "if x is positive and not +0, then the result of sign(x) is 1";
  1;
  Math.sign();
  1;
  "if x is positive and not +0, then the result of sign(x) is 1";
  1;
  Math.sign();
  200;
  "if x is positive and not +0, then the result of sign(x) is 1";
  1;
  Math.sign();
  Infinity;
  "if x is positive and not +0, then the result of sign(x) is 1";
}

t15();

function t16() {
  NaN;
  Math.cbrt();
  NaN;
  "if x is NaN, then the result of cbrt(x) is NaN";
  +0;
  Math.cbrt();
  +0;
  "if x is +0, then the result of cbrt(x) is +0";
  -0;
  Math.cbrt();
  -0;
  "if x is -0, then the result of cbrt(x) is -0";
  +Infinity;
  Math.cbrt();
  +Infinity;
  "if x is +Infinity, then the result of cbrt(x) is +Infinity";
  -Infinity;
  Math.cbrt();
  -Infinity;
  "if x is -Infinity, then the result of cbrt(x) is -Infinity";
  1;
  Math.cbrt();
  1;
  "cbrt(1) = 1";
  -1;
  Math.cbrt();
  -1;
  "cbrt(-1) = -1";
  2;
  Math.cbrt();
  8;
  "cbrt(8) = 2";
  -2;
  Math.cbrt();
  -8;
  "cbrt(-8) = -2";
  5;
  Math.cbrt();
  125;
  "cbrt(125) = 5";
  -5;
  Math.cbrt();
  -125;
  "cbrt(-125) = -5";
}

t16();

function t17() {
  function assertFunctionExactlyEqual2ForAllY(expected, fn, x, message) {
    expected;
    fn;
    x;
    NaN;
    message + " for all y (y === NaN)";
    expected;
    fn;
    x;
    +Infinity;
    message + " for all y (y === +Infinity)";
    expected;
    fn;
    x;
    -Infinity;
    message + " for all y (y === -Infinity)";
    expected;
    fn;
    x;
    +0;
    message + " for all y (y === +0)";
    expected;
    fn;
    x;
    -0;
    message + " for all y (y === -0)";
    expected;
    fn;
    x;
    +0.5;
    message + " for all y (y === +0.5)";
    expected;
    fn;
    x;
    -0.5;
    message + " for all y (y === -0.5)";
    expected;
    fn;
    x;
    +1;
    message + " for all y (y === +1)";
    expected;
    fn;
    x;
    -1;
    message + " for all y (y === -1)";
    expected;
    fn;
    x;
    +1.5;
    message + " for all y (y === +1.5)";
    expected;
    fn;
    x;
    -1.5;
    message + " for all y (y === -1.5)";
    expected;
    fn;
    x;
    +50;
    message + " for all y (y === +50)";
    expected;
    fn;
    x;
    -50;
    message + " for all y (y === -50)";
    expected;
    fn;
    x;
    +12345.67;
    message + " for all y (y === +12345.67)";
    expected;
    fn;
    x;
    -12345.67;
    message + " for all y (y === -12345.67)";
  }

  +0;
  Math.imul();
  NaN;
  "if x is NaN, then the result of imul(x,y) is +0";
  +0;
  Math.imul();
  +0;
  "if x is +0, then the result of imul(x,y) is +0";
  +0;
  Math.imul();
  -0;
  "if x is -0, then the result of imul(x,y) is +0";
  +0;
  Math.imul();
  +Infinity;
  "if x is +Infinity, then the result of imul(x,y) is +0";
  +0;
  Math.imul();
  -Infinity;
  "if x is -Infinity, then the result of imul(x,y) is +0";
  0;
  Math.imul();
  0;
  0;
  "imul(0,0) is 0";
  0;
  Math.imul();
  0;
  1;
  "imul(0,0) is 0";
  0;
  Math.imul();
  1;
  0;
  "imul(0,0) is 0";
  1;
  Math.imul();
  1;
  1;
  "imul(0,0) is 0";
  6;
  Math.imul();
  2;
  3;
  "imul(0,0) is 0";
  -8;
  Math.imul();
  4;
  -2;
  "imul(0,0) is 0";
  1024;
  Math.imul();
  32;
  32;
  "imul(0,0) is 0";
  0;
  Math.imul();
  65536;
  65536;
  "imul(2^16,2^16) is 0 because imul is modulo 2^32";
  -2147483648;
  Math.imul();
  32768;
  65536;
  "imul(2^15,2^16) is -2^31 because imul is modulo 2^32 and subtracts 2^31 if the value would be greater than or equal to 2^31";
  -2147418112;
  Math.imul();
  32769;
  65536;
  "imul(2^15 + 1,2^16) is -2^31 + 65536 because imul is modulo 2^32 and subtracts 2^31 if the value would be greater than or equal to 2^31";
}

t17();

function t18() {
  32;
  Math.clz32();
  0x00000000;
  "32 leading zero bits in the uint32 value 0x00000000";
  31;
  Math.clz32();
  0x00000001;
  "31 leading zero bits in the uint32 value 0x00000001";
  30;
  Math.clz32();
  0x00000002;
  "30 leading zero bits in the uint32 value 0x00000002";
  29;
  Math.clz32();
  0x00000004;
  "29 leading zero bits in the uint32 value 0x00000004";
  28;
  Math.clz32();
  0x00000008;
  "28 leading zero bits in the uint32 value 0x00000008";
  27;
  Math.clz32();
  0x00000010;
  "27 leading zero bits in the uint32 value 0x00000010";
  26;
  Math.clz32();
  0x00000020;
  "26 leading zero bits in the uint32 value 0x00000020";
  25;
  Math.clz32();
  0x00000040;
  "25 leading zero bits in the uint32 value 0x00000040";
  24;
  Math.clz32();
  0x00000080;
  "24 leading zero bits in the uint32 value 0x00000080";
  23;
  Math.clz32();
  0x00000100;
  "23 leading zero bits in the uint32 value 0x00000100";
  22;
  Math.clz32();
  0x00000200;
  "22 leading zero bits in the uint32 value 0x00000200";
  21;
  Math.clz32();
  0x00000400;
  "21 leading zero bits in the uint32 value 0x00000400";
  20;
  Math.clz32();
  0x00000800;
  "20 leading zero bits in the uint32 value 0x00000800";
  19;
  Math.clz32();
  0x00001000;
  "19 leading zero bits in the uint32 value 0x00001000";
  18;
  Math.clz32();
  0x00002000;
  "18 leading zero bits in the uint32 value 0x00002000";
  17;
  Math.clz32();
  0x00004000;
  "17 leading zero bits in the uint32 value 0x00004000";
  16;
  Math.clz32();
  0x00008000;
  "16 leading zero bits in the uint32 value 0x00008000";
  15;
  Math.clz32();
  0x00010000;
  "15 leading zero bits in the uint32 value 0x00010000";
  14;
  Math.clz32();
  0x00020000;
  "14 leading zero bits in the uint32 value 0x00020000";
  13;
  Math.clz32();
  0x00040000;
  "13 leading zero bits in the uint32 value 0x00040000";
  12;
  Math.clz32();
  0x00080000;
  "12 leading zero bits in the uint32 value 0x00080000";
  11;
  Math.clz32();
  0x00100000;
  "11 leading zero bits in the uint32 value 0x00100000";
  10;
  Math.clz32();
  0x00200000;
  "10 leading zero bits in the uint32 value 0x00200000";
  9;
  Math.clz32();
  0x00400000;
  "9 leading zero bits in the uint32 value 0x00400000";
  8;
  Math.clz32();
  0x00800000;
  "8 leading zero bits in the uint32 value 0x00800000";
  7;
  Math.clz32();
  0x01000000;
  "7 leading zero bits in the uint32 value 0x01000000";
  6;
  Math.clz32();
  0x02000000;
  "6 leading zero bits in the uint32 value 0x02000000";
  5;
  Math.clz32();
  0x04000000;
  "5 leading zero bits in the uint32 value 0x04000000";
  4;
  Math.clz32();
  0x08000000;
  "4 leading zero bits in the uint32 value 0x08000000";
  3;
  Math.clz32();
  0x10000000;
  "3 leading zero bits in the uint32 value 0x10000000";
  2;
  Math.clz32();
  0x20000000;
  "2 leading zero bits in the uint32 value 0x20000000";
  1;
  Math.clz32();
  0x40000000;
  "1 leading zero bit in the uint32 value 0x40000000";
  0;
  Math.clz32();
  0x80000000;
  "0 leading zero bits in the uint32 value 0x80000000";
  28;
  Math.clz32();
  0x0000000A;
  "28 leading zero bits in the uint32 value 0x0000000A, same as 0x00000008";
  17;
  Math.clz32();
  0x00007ABC;
  "17 leading zero bits in the uint32 value 0x00007ABC, same as 0x00004000";
  3;
  Math.clz32();
  0x10380FE1;
  "3 leading zero bits in the uint32 value 0x10380FE1, same as 0x10000000";
  32;
  Math.clz32();
  undefined;
  "Undefined converts to +0 therefore 32 leading zero bits";
  32;
  Math.clz32();
  "hello";
  "Non-number string converts to +0 therefore 32 leading zero bits";
  2;
  Math.clz32();
  "0x20000000";
  "Number string converts to that number therefore however many leading zero bits";
  var o = {
    valueOf: function () {
      return 0x00800000;
    }
  };
  8;
  Math.clz32();
  o;
  "Object with valueOf method converts to result of that method therefore however many leading zero bits";
}

t18();

function t19() {
  NaN;
  Math.fround();
  NaN;
  "if x is NaN, then the result of fround(x) is NaN";
  +Infinity;
  Math.fround();
  +Infinity;
  "if x is +Infinity, then the result of fround(x) is +Infinity";
  -Infinity;
  Math.fround();
  -Infinity;
  "if x is -Infinity, then the result of fround(x) is -Infinity";
  +0;
  Math.fround();
  +0;
  "if x is +0, then the result of fround(x) is +0";
  -0;
  Math.fround();
  -0;
  "if x is -0, then the result of fround(x) is -0";
  +1;
  Math.fround();
  +1;
  "if x is +1, then the result of fround(x) is +1";
  -1;
  Math.fround();
  -1;
  "if x is -1, then the result of fround(x) is -1";
  +2;
  Math.fround();
  +2;
  "if x is +2, then the result of fround(x) is +2";
  -2;
  Math.fround();
  -2;
  "if x is -2, then the result of fround(x) is -2";
  +5;
  Math.fround();
  +5;
  "if x is +5, then the result of fround(x) is +5";
  -5;
  Math.fround();
  -5;
  "if x is -5, then the result of fround(x) is -5";
  +100;
  Math.fround();
  +100;
  "if x is +100, then the result of fround(x) is +100";
  -100;
  Math.fround();
  -100;
  "if x is -100, then the result of fround(x) is -100";
  +0.5;
  Math.fround();
  +0.5;
  "if x is +0.5, then the result of fround(x) is +0.5";
  -0.5;
  Math.fround();
  -0.5;
  "if x is -0.5, then the result of fround(x) is -0.5";
  let testcase = [// numbers between zero and one
  [0.5995356650091708, 0.5995356440544128], [0.4388806028291583, 0.43888059258461], [0.05652953824028373, 0.056529536843299866], [0.8834999229293317, 0.8834999203681946], [0.19564732676371932, 0.19564732909202576], [0.04695801460184157, 0.046958014369010925], [0.995549641083926, 0.9955496191978455], [0.5965264535043389, 0.5965264439582825], [0.3384522853884846, 0.3384522795677185], [0.4793784348294139, 0.47937843203544617], // large integers
  [968719029287650, 968719001976832], [612872438100595, 612872438677504], [986007985043197, 986007990173696], [229849530517651, 229849536921600], [1069224778058320, 1069224793473024], [404824585745150, 404824591958016], [980853506006873, 980853492547584], [156784970534624, 156784962568192], [416562781028203, 416562771132416], [724128106542317, 724128130662400], // arbitrary numbers
  [6785.904748927644, 6785.90478515625], [5.585741676777502, 5.5857415199279785], [0.1787555584523126, 0.17875555157661438], [45167.42179931141, 45167.421875], [53.97847279046722, 53.97847366333008], [708731082.0651336, 708731072], [786033.2273395439, 786033.25], [134428002986767.81, 134428005236736], [10598756866706, 10598756646912], [2316.058639210134, 2316.05859375]];

  for (let i = 0; i < testcase.length; i++) {
    testcase[i][1];
    Math.fround();
    testcase[i][0];
    "if x is " + testcase[i][0] + ", then the result of fround(x) is " + testcase[i][1];
  } // Test against type specialization bugs
  //  -bgjit- -maxinterpretcount:1 -maxsimplejitruncount:2


  function fround_testsub() {
    protoObj2.prop0 = Math.fround(1);
    return protoObj2.prop0;
  }

  let obj2 = {};
  let protoObj2 = Object.create(obj2);
  fround_testsub();
  fround_testsub();
  fround_testsub(); // ok till this point

  console.log(1, fround_testsub());
}

t19();
